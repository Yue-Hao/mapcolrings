;;Xiaosheng Li
;;CS 580 Fall 2014
;;Dr. Duric
;;Project

;; treecoloring.lisp
;; this module includes funciton to color a tree(forrest) by firstly do a
;; topological sort of the tree, secondly color the tree very efficently

(defun check-legal-assign (states coloring)
  "check if one color assignment is leagal using recursive call
   this function is only for testing"
  (let ((assigned_states (intersection states coloring :key #'first)))
    (dolist (x assigned_states coloring)
      (if (every (lambda (y)
		   (if (not (eq (second (assoc (first x) coloring))
				(second (assoc y coloring))))
		       T
		       nil))
		 (second x))
	  T
	  (return (setf coloring nil))))))

(defun gen-tree-domains (cs_coloring t_sorted states colors)
  "dsg"
  (let ((full_domains (mapcar (lambda (x)
				(list (first x) colors))
			      t_sorted)))
    (mapcar (lambda (x)
	      (let ((bad_colors (mapcar (lambda (y)
					  (second (assoc y cs_coloring)))
					(second (assoc (first x) states)))))
		(list (first x) (set-difference (second x) bad_colors))))
	    full_domains)))

(defun gen-tree-colorings-aux (t_coloring t_sorted domains c_coloring states)
  (let ((n (first t_sorted)))
    (if (null t_sorted)
	(print (append c_coloring t_coloring))
	;;(if (not (check-legal-assign states (append c_coloring t_coloring)))
	;;    (print "error!"))
	(let ((parent_color (second (assoc (second n) t_coloring))))
	  (dolist (x (remove parent_color (second (assoc (first n) domains))))
	    (gen-tree-colorings-aux (append t_coloring (list (list (first n) x)))
				    (rest t_sorted)
				    domains
				    c_coloring
				    states))))))
  
  
(defun gen-tree-colorings (t_sorted c_coloring states colors)
  "T the graph of the remaining tree(forrest), should be topologically sorted!"
  (let ((domains (gen-tree-domains c_coloring t_sorted states colors)))
    (if (not (some #'null (mapcar #'second domains)))
	(gen-tree-colorings-aux '()
				t_sorted
				domains
				c_coloring
				states))))
				



(defun del (x map)
  "helper function to delete a element"
	(mapcar #'(lambda (z) 
		(cons (first z) (list (mapcan #'(lambda (a) 
			(if (eql a x) (setf a nil) (list a))) (second z))))) map))

(defun del-element (el map)
  (del el (remove-if #'(lambda (x) (eql (first x) el)) map)))

(defun topological-sort (tree)
  "order the nodes from root to leaf"
  (do ((newtree nil) (children (list (list (first (first tree)) nil))) (newchildren nil nil)) 
      ((null tree) newtree)
    (setf newtree (append newtree children))
    (dolist (x children)
      (setf newchildren
	    (append newchildren 
		    (mapcar #'
		     (lambda (y) (list y (first x))) (second (assoc (first x) tree))))))
    (dolist (z children)
      (setf tree (del-element (first z) tree)))
    (if (null newchildren) (setf children (list (list (first (first tree)) nil)))
	(setf children (remove-if #'(lambda (x) (null (first x))) newchildren)))))
